//该代码是多态条件下的一个易混知识点，主要想强调引用变量和创建的实例对象之间的关系
//假设有两个类，名字分别是A和C，其中A是C的父类
//A a =new A();中，等号左边是引用变量声明，引用A类中的实例变量和方法，名称为a。等号右边是创建A类的一个实例对象，拥有A类的实例变量和方法
//引用变量相当于遥控器，自身类所拥有的方法就是上面的按钮
//创建的实例对象相当于被遥控的物体，当引用变量按下按钮时，执行的是自身上与按钮同名的方法，而执行的结果由自身定义决定，和引用变量所在类定义的同名方法不一定相同
//举例 A a2 = new C();左边是引用A类的引用变量a2，右边创建了C类的一个实例对象，那么两者可以联系在一起吗？
//可以，但a2的按钮有限，只有A类自身定义的方法m1和m2。而以C类创建的对象呢？有继承自A类的m2,和自己修改A类的m1以及自己自创的m3动作可以执行
//那么a2按下m2时（即a2.m2();），当然对象先找到m2方法，只在父类A中找到了，会执行A中的m2方法结果显示  A's m2
//那么a2按下m1时（即a2.m1();），对象找了一下，自己和父类都有m1方法，但是自己的最近，因此执行自己修改过的m1方法，显示c's m1
//那么a2按下m3时（即a2.m3();）对象确实有m3方法，但由于引用变量a2根本没有m3方法，相当于根本没有m3按钮，因此执行会出错，显示 错误: 找不到符号    a2.m3();             
class A {
	public void m1 (){
		System.out.print("A's m1 ");
	}
	public void m2 (){
		System.out.print("A's m2 ");
	}
}
class C extends A {
	public void m1 (){
		System.out.print("C's m1 ");
	}
	public void m3 (){
		System.out.print("C's m3 ");//新增父类中没有的方法
	}
}
public class mix {
	public static void main(String[] args){ 
		A a = new A();
		C c = new C();
		A a2 = new C();
		c.m1();//执行正确，输出c's m1
		a2.m1();//执行正确，输出c's m1
		a2.m3();//错误: 找不到符号    a2.m3(); 
	}
}
//顺便一提，A a = new A();等号右边	= new A();其实挺像方法调用的，其实不然，我们是在调用A类的构造函数
//构造函数与类同名，没有返回类型，且只在前面有关键字new时执行，就算自己没有编译，编译器也会自动创建

	